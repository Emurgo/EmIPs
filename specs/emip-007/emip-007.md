---
EmIP: 7
Title: Wallet Export Format
Authors: Sebastien Guillemot <sebastien@emurgo.io>
Comments-URI: TODO
Status: Draft
Type: Standards
Created: 2020-04-30
License: Apache-2.0
---

## Abstract

Wallet-managing software aims to make it easy for users to restore their wallet at any time. Although standards like [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) make this it easy to share keys across different wallet-managing software, it does not cover all possible wallet configurations.

This standard aims to make a wallet export format generic enough cover all types of wallets.

## Motivation

There are two main motivations

1. Improved user experience for wallet types that require large manuel effort to create \
  An example is a "balance tracking" wallet where the user simply specified a list of addresses whose balance they want to track. Since there is no key derivation involved, re-creating a "balance tracking" wallet involves tediously copying all the addresses.

2. Handling wallets where only the private key is known (no bip39 recovery phrase) \
  This most commonly happens if the user forgets their recovery phrase but still remember their spending password. Usually when this happens, the should generate a new wallet where they know the bip39 recovery phrase and then send all their funds to the new wallet. However, in cases like the Jormungandr testnet, users are unable to send their rewards to a new wallet. Therefore, they need a safe way to export their private key from their Shelley testnet wallet and then import it into their mainnet wallet.

## Specification

### Terminology

**Derivation levels**: Derivation levels are defined as the number of key derivations from some root key \
*Ex:* [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki). Levels are given names according to specific standards such as in [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)
*Note*: Derivation levels start with 0 being the root. This may seem counter-intuitive since you might think the "highest level" would be the root (if you think of it like a tree), but this is ambiguous because the "highest level" in BIP44 for example could refer to the "address" level (level 5) since it is numerically the highest. To avoid this ambiguity, one should use "leftmost" and "rightmost" to reflect the derivation path notation.

**Public deriver level**: This is derivation level of the entity that is shown inside the wallet-management software (typically the the right-most hardened derivation if one exists) \
*Note:* A *public deriver level* does not indicate we know a *public key* for that level. For example, in the balance tracker wallet, the *public deriver level* is the address level even though we may not know the public key that generated the address.

**Derived wallet**: a wallet where keys in the *public deriver level* are generated from a key that is known by the wallet-managing software. \
*Ex:* A BIP44 wallet generated from a BIP39 recovery phrase managed entirely by wallet-management software is a derived wallet with the bip44 account level being the *public deriver level*
*Ex:* The v1 of AdaLite was a derived wallet with the bip44 chain level being the *public deriver level* (it only used the external chain)

**Adhoc derivation**: A wallet where information in the *public deriver level* is is taken as a given (possibly generated from a key that is not known the highest wallet knows a key (public or private) without knowing the key of any of its parents. \
*Ex:* BIP44-compliant hardware wallets are adhoc accounts (no parent key is known -- you only know the account public key) \
*Ex:* Balance tracking wallets is adhoc address-level derivations \

**Conceptual wallet**: Defines common metadata about a group of public derivers. \
*Ex:* Needs to keep track of what network a wallet is for \
*Ex:* Needs to give a title to a group of adhoc derivations or any multi-account wallet.

**Private deriver level**: The key level used to generate new public derivers in a derived wallet

**Signer level**: The key level used to sign transactions. \
*Note:* This is not always equal to the *private deriver level*. For example, you could have a derived multi-account wallet where each account has a different spending password

### A note on derivation paths

Derivation paths do not contain just information about key derivation, but can in fact hold other information.

The best example of this is the chain derivation level in BIP44. The "external" chain needs to keep track of the last index manually generated by the user. Users can generate up to 20 addresses after the last used index according to BIP44, and so this information needs to be tracked by the wallet software and ideally part of the wallet export format.

### Format

```javascript
{
  "version": number,
  // contents of this key should be encrypted
  "walletInfo": {
    "Key": Array<{
      "KeyId": number,
      "Hash": string,
      "IsEncrypted": boolean,
      "PasswordLastUpdate": Date | null
    }>,
    "Address": Array<{
      "AddressId": number,
      "Type": number,
      "Hash": string
    }>,
    "CanonicalAddress": Array<{
      "KeyDerivationId": number,
      "CanonicalAddressId": number
    }>,
    "AddressMapping": Array<{
      "KeyDerivationId": number,
      "AddressId": number,
      "AddressMappingId": number
    }>,
    "KeyDerivation": Array<{
      "KeyDerivationId": number,
      "PrivateKeyId": number | null,
      "PublicKeyId": number | null,
      /** no parent for root derivation */
      "Parent": number | null,
      /**
        * No index in root case
        * Additionally, this is useful for adhoc wallet
        * since it allows us to put empty derivations in a derivation chain
        *
        * ex: adhoc chain wallet so we don't know the account
        * but we can still specify the purpose & cointype by adding an empty account derivation
        */
      "Index": number | null
    }>,
    "PublicDeriver": Array<{
      "PublicDeriverId": number,
      "ConceptualWalletId": number,
      "KeyDerivationId": number,
      "Name": string,
      /** need to allow user to re-order public derivers in UI */
      "Index": number
    }>,
    "HwWalletMeta": Array<{
      "ConceptualWalletId": number,
      "Vendor": string,
      "Model": string,
      "DeviceId": string
    }>,
    "RootDerivation": Array<{
      "RootDerivationId": number,
      "KeyDerivationId": number
    }>,
    "PurposeDerivation": Array<{
      "PurposeDerivationId": number,
      "KeyDerivationId": number
    }>,
    "CoinTypeDerivation": Array<{
      "CoinTypeDerivationId": number,
      "KeyDerivationId": number
    }>,
    "Bip44Account": Array<{
      "Bip44AccountId": number,
      "KeyDerivationId": number
    }>,
    "Bip44Chain": Array<{
      "Bip44ChainId": number,
      "KeyDerivationId": number,
      "DisplayCutoff": number | null
    }>,
    "Bip44Wrapper"?: Array<{
      "ConceptualWalletId": number,
      "SignerLevel": number | null,
      "PublicDeriverLevel": number,
      "PrivateDeriverLevel": number | null,
      "PrivateDeriverKeyDerivationId": number | null,
      /** Need to keep track of root ID to cleanup when wallet is removed */
      "RootKeyDerivationId": number
    }>,
    "Cip1852Wrapper"?: Array<{
      "ConceptualWalletId": number,
      "SignerLevel": number | null,
      "PublicDeriverLevel": number,
      "PrivateDeriverLevel": number | null,
      "PrivateDeriverKeyDerivationId": number | null,
      /** Need to keep track of root ID to cleanup when wallet is removed */
      "RootKeyDerivationId": number
    }>,
  },
  // note: not encrypted so we can show it to the user
  "ConceptualWallet": Array<{
    "ConceptualWalletId": number,
    "CoinType": number,
    "Name": string,
    "NetworkId": number,
    /** should not be stored in the wallet. Only used to show checksum to user when decrypting */
    "Checksum": null | {
      "ImagePart": string,
      "TextPart": string,
    }
  }>,
}
```

### Encryption

The `walletInfo` section should be encrypted using the same algorithm as described by [EMIP3](https://github.com/Emurgo/EmIPs/blob/master/specs/emip-003.md) using a *decryption password*.

*Note:* Although the ordering of the JSON keys doesn't matter for encryption, one SHOULD remove any un-neeeded whitespace to shrink the payload size.

## Rationale

### Why is part of the format encrypted?

All identifiable information should be encrypted for maximum safety. However, information like wallet name and checksum do not reveal sensitive information and help the user know what is contained in the file (potentially also reminding them what the *decryption password* is).

**Note**: we cannot encrypt with the user's spending password, as no spending password is available in cases like hardware wallets or read-only wallets.

### What about user-labeled data?

We don't export memos / labels or similar information since there is no way to comprehensively include them all in this specification (recall: different wallets could handle different kinds of user-labeled data). These should be specified as a different CIP and probably synced using a cloud storage provider instead of a wallet export.

### What about transaction history?

We don't need to include transaction history as it can be inferred from the blockchain

### What is `AddressMapping` and why do we need it?

A single derivation path can actually define multiple different address types. For example, in Cardano Shelley, a single derivation can define both "base" addresses and "enterprise" addresses. We therefore need a one-to-many mapping from the derivation to the addresses. The addresses need to be in a standalone table since rows in the address required for other metadata may not belong to your wallet.

### How to handle multiple currencies from the same recovery phrase

This format doesn't allow generating multiple currencies from a single recovery phrase. That would require another level above *ConceptualWallet*. This is because *ConceptualWallet* has to store information like the network ID for all its public derivers (which is a currency-specific concept).s

### Why are addresses included if they can be derived from the public deriver?

I include the addresses as although they can be derived when a public key is present, they cannot be derived in the balance tracker case. Additionally, it's possible in the future that some new metadata that needs to be tracked contains a foreign key to an address. Therefore, it's easier to just add them in the wallet export.

### Why are empty wrappers not included

We don't add empty wrapper arrays for forwards compatibility. Even if a future wallet format that introduces a new wrapper type, importing then exporting a wallet would still result in the same file.

## Reference implementation

How these files are converted from/to a wallet's internal representation is very much implementation specific. Instead, we attach two example files to this EmIP.

## Copyright

This EmIP is licensed under [Apache-2.0](https://www.apache.org/licenses/LICENSE-2.0)
